using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Vulnerability
{
    static class Tests
    {
        /// <summary>
        /// Тест Вальда-Вольфовитца
        /// </summary>
        /// <param name="length">размер массива</param>
        /// <param name="arr">массив данных</double></param>
        /// <returns></returns>
        static public double Wald_Wolfowitz(int length, List<double> arr)
        {
            int n1 = length / 2, n2;
            double criterion = 1.0;
            double[,] ar = new double[3, length];
            double Z;
            n2 = (length % 2 == 0) ? n1 : n1 + 1;
            for (int i = 0; i < length; i++)
            {
                ar[0, i] = i < n1 ? 1 : 2;// Разбитие на 2-е подгруппы
                ar[1, i] = arr[i]; // В столбец с номером 1 записываются элементы исходных данных
                ar[2, i] = 0;
            }
            Sort.QuickSort(ar, 0, length - 1); // Сортировка элементов массива
            for (int i = 0; i < length - 1; i++)
                if (ar[0, i] != ar[0, i + 1])
                    criterion++;
            double z1, z2;
            z1 = Math.Abs(criterion - (((2.0 * n1 * n2) / (n1 + n2)) + 1)) - 0.5;
            z2 = Math.Sqrt((2.0 * n1 * n2 * (2.0 * n1 * n2 - n1 - n2)) / ((n1 + n2) * (n1 + n2) * (n1 + n2 - 1.0)));
            Z = z1 / z2;
            return Math.Round(Z, 5);
        }

        //-------------------------------------Манн-Уитни ---------------------------------------------

        /// <summary>
        /// Тест Манна-Уитни
        /// </summary>
        /// <param name="length">размер массива</param>
        /// <param name="arr">массив данных</param>
        /// <returns>Возвращает случайную величину Z</returns>
        static public double[] Mann_Whitney(int length, List<double> arr)
        {
            int newLength = length / 2;
            double R1 = newLength;
            double R2 = 0;
            double[] U = new double[3];
            double[,] ar = new double[3, length];
            for (int i = 0; i < length; i++)
            {
                ar[0, i] = (i < length / 2) ? 1 : 2;// Разбитие на 2-е подгруппы     
                ar[1, i] = arr[i]; // В столбец с номером 1 записываются элементы исходных данных
                ar[2, i] = 0;
            }
            Sort.QuickSort(ar, 0, length - 1); // Сортировка элементов массива
            int k = 1;
            double Si = 0;
            for (int i = 0; i < length - 1; i++) // Ранжировка
            {
                if (ar[1, i] == ar[1, i + 1])
                {
                    k++;
                    Si += i;
                    if (i == length - 2) // Для последнего элемента
                    {
                        Si += i + 1;
                        ar[2, i + 1] = Si / k;
                        if (k > 1) // Для того, чтобы элементы с одинаковыми значениями стали с одинаковыми рангами
                            for (int j = i + 1; j > i + 1 - k; j--)
                                ar[2, j] = ar[2, i + 1];
                    }
                }
                else
                {
                    Si += i;
                    ar[2, i] = Si / k;
                    if (k > 1) // Для того, чтобы элементы с одинаковыми значениями стали с одинаковыми рангами
                        for (int j = i; j > i - k; j--)
                            ar[2, j] = ar[2, i];
                    if (i == length - 2) // Для последнего элемента
                        ar[2, i + 1] = length - 1;
                    k = 1;
                    Si = 0;
                }
            }
            R2 = (length % 2 == 0) ? newLength : (newLength + 1);
            int R2_2 = (int)R2; // Дополнительная переменная со значением количества элементов, если количество элементов нечётное
            double U1 = 0, U2 = 0;
            for (int i = 0; i < length; i++) // Суммируются ранги, затем подсчитываем инверсии
            {
                if (ar[0, i] == 1)
                    R1 += ar[2, i];
                else
                    R2 += ar[2, i];
            }
            for (int i = 0; i < length; i++) // Суммируются ранги, затем подсчитываем инверсии
            {
                U1 = newLength * R2_2 + (R2_2 * (R2_2 + 1.0)) / 2.0 - R2;
                U2 = newLength * R2_2 + (newLength * (newLength + 1.0)) / 2.0 - R1;
            }
            U1 = (U1 < U2) ? U1 : U2;
            double Z = 0;
            for (int i = 0; i < length - 1; i++)
            {
                if (length >= 20) // вычисление нормированной случайной величины z
                {
                    double Zch = ((Math.Abs(U1 - (newLength * R2_2) / 2.0)) - 0.5);
                    if (ar[1, i] == ar[1, i + 1]) // Если в выборках наблюдаются повторяющиеся значения, то Z вычисляется так
                    {
                        double Sum = (Math.Pow((newLength + R2_2), 3)) - (newLength + R2_2) - Mann_WhitneyDuplicateValues(ar, length);
                        double Zzn = (newLength * R2_2) / (12.0 * (newLength + R2_2) * (newLength + R2_2 - 1.0));
                        Zzn = Math.Sqrt(Zzn * Sum);
                        Z = Zch / Zzn;
                    }
                    else // Если в выборках нет повторяющихся значений, то Z вычисляется так
                    {
                        double Zzn = Math.Sqrt((newLength * R2_2 * (newLength + R2_2 + 1)) / 12);
                        Z = Zch / Zzn;
                    }
                    U[0] = Math.Round(Z, 4);
                    U[1] = newLength;
                    U[2] = R2_2;
                }
                else
                {
                    U[0] = Math.Round(U1, 4);
                    U[1] = newLength;
                    U[2] = R2_2;
                }
            }
            return U;
        }

        /// <summary>
        ////Расчёт поправки для теста Манна-Уитни
        /// </summary>
        /// <param name="ar">двумерный массив</param>
        /// <param name="length">длина</param>
        /// <returns></returns>
        private static double Mann_WhitneyDuplicateValues(double[,] ar, int length)
        {
            double[] a = new double[length];
            for (int i = 0; i < length; i++)
                a[i] = ar[2, i];
            double Sum = 0;
            Dictionary<double, double> di = new Dictionary<double, double>();
            var g = a.GroupBy(i => i);
            int c = 0;
            foreach (var k in g)
                if (k.Count() == 1)
                    c++;
                else
                    di.Add(k.Key, k.Count());
            double[,] Array = ConvertDictionaryTo2dArray(di);
            for (int j = 0; j < Array.Length / 2; j++)
                Sum += (Math.Pow(Array[1, j], 3) - Array[1, j]);
            return Sum;
        }

        /// <summary>
        /// Конвертирование из Dictionary в двумерный массив
        /// </summary>
        /// <param name="dictionary"></param>
        /// <returns></returns>
        private static double[,] ConvertDictionaryTo2dArray(Dictionary<double, double> dictionary)
        {
            double[,] Array = new double[2, dictionary.Count];
            int i = 0;
            foreach (KeyValuePair<double, double> item in dictionary)
            {
                Array[0, i] = item.Key;
                Array[1, i] = item.Value;
                i++;
            }
            return Array;
        }

        //-------------------------------------Сиджел-Тьюки---------------------------------------------

        static public double Siegel_Tukey(int length, List<double> arr)
        {
            int newLength = length / 2;
            double R1 = 0;
            double R2 = 0;
            double[] U = new double[2];
            double[,] ar = new double[3, length];
            double z = 0;
            double M = 0;
            double G = 0;
            bool q = true;
            int k = 1;
            for (int i = 0; i < length; i++)
            {
                if (i < length / 2) // Разбитие на 2-е подгруппы
                    ar[0, i] = 1;
                else
                    ar[0, i] = 2;
                ar[1, i] = arr[i]; // В столбец с номером 1 записываются элементы исходных данных
                ar[2, i] = 0;
            }
            Sort.QuickSort(ar, 0, length - 1); // Сортировка элементов массива
            ar[2, 0] = 1;
            for (int i = 1; i < (length + 2) / 2; i++)
            {
                if (q == true)
                {
                    k += 3;
                    ar[2, i] = k;
                    q = false;
                }
                else
                {
                    k += 1;
                    ar[2, i] = k;
                    q = true;
                }
            }
            q = false;
            k = -1;
            for (int i = length - 1; i > (length - 1) / 2; i--)
            {
                if (q == false)
                {
                    k += 3;
                    ar[2, i] = k;
                    q = true;
                }
                else
                {
                    k += 1;
                    ar[2, i] = k;
                    q = false;
                }
            }
            k = 1;
            double Si = 0;
            for (int i = 0; i < length - 1; i++)
            {
                if (ar[1, i] == ar[1, i + 1])
                {
                    k++;
                    Si += ar[2, i];
                    if (i == length - 2)
                    {
                        Si += ar[2, i + 1];
                        ar[2, i] = Si / k;
                        ar[2, i + 1] = Si / k;
                    }
                }
                else
                {
                    Si += ar[2, i];
                    for (int j = i; j > i - k; j--)
                        ar[2, j] = Si / k;
                    k = 1;
                    Si = 0;
                }
            }
            int R2_2 = 0; // Дополнительная переменная со значением количества элементов, если количество элементов нечётное
            if (length % 2 == 0)
                R2_2 = newLength;
            else
                R2_2 = newLength + 1;
            for (int i = 0; i < length; i++) // Суммируются ранги
            {
                if (ar[0, i] == 1)
                    R1 += ar[2, i];
                else
                    R2 += ar[2, i];
            }
            M = newLength / 2 * (newLength + R2_2 + 1);
            G = Math.Sqrt((newLength * R2_2 * (newLength + R2_2 + 1)) / 12);
            if (R1 <= R2)
                z = ((Math.Abs(R1 - M)) - 0.5) / G;
            else
                z = ((Math.Abs(R2 - M)) - 0.5) / G;
            return Math.Round(z, 5);
        }

        //-------------------------------------Херст ---------------------------------------------

        static public double Herst(List<double> arr, int length)
        {            
            int parts = 10;
            int newLength = length / parts;
            double[,] mas_chisel = new double[parts, newLength];
            for (int i = 0; i < parts; i++)
                for (int j = 0; j < newLength - 1; j++)
                    mas_chisel[i, j] = Math.Log(mas_chisel[i, j + 1] / mas_chisel[i, j]);
            double[,] mas = new double[parts, newLength];
            int k = 0;
            for (int i = 0; i < parts; i++) // Разбиение на 'parts' частей и запись в 2d массив
                for (int j = 0; j < newLength; j++)
                {
                    mas[i, j] = Convert.ToDouble(arr[k]);
                    k++;
                }
            double[] Sred = new double[parts];
            double Sum = 0;
            for (int i = 0; i < parts; i++) // Для каждого подпериода находим среднее арифметическое
            {
                for (int j = 0; j < newLength; j++)
                    Sum += mas[i, j];
                Sred[i] = Sum / newLength;
                Sum = 0;
            }
            double[,] X = new double[parts, newLength];
            double[,] Xcopy = new double[parts, newLength];
            for (int i = 0; i < parts; i++) // Временной ряд накопленных отклонений
                for (int j = 0; j < newLength; j++)
                {
                    X[i, j] = (mas[i, j] - Sred[i]);
                    Xcopy[i, j] = Math.Pow((mas[i, j] - Sred[i]), 2); // Для S
                }
            k = 0;
            Sum = 0;
            for (int i = 0; i < parts; i++)
                for (int j = 0; j < newLength; j++)
                {
                    Sum = Sum + X[i, j];
                    X[i, j] = Sum;
                    k++;
                }
            double[] R = new double[parts];
            for (int i = 0; i < parts; i++) // Размах R
            {
                double max = 0, min = 0;
                for (int j = 0; j < newLength; j++)
                {
                    max = Math.Max(max, X[i, j]);
                    min = Math.Min(min, X[i, j]);
                    R[i] = max - min;
                }
            }
            double[] S = new double[parts];
            k = 0;
            Sum = 0;
            for (int i = 0; i < parts; i++) // Стандартное отклонение S
            {
                for (int j = 0; j < newLength; j++)
                {
                    Sum = Sum + Xcopy[i, j];
                    S[i] = Sum;
                    k++;
                }
                Sum = 0;
                S[i] /= (newLength);
                S[i] = Math.Sqrt(S[i]);
            }
            double[] RS = new double[parts];
            Sum = 0;
            double logRS = 0;
            for (int i = 0; i < parts; i++) // Нормированный розмах RS
                RS[i] = R[i] / S[i];
            for (int i = 0; i < parts; i++)
                Sum += RS[i];
            Sum = Sum / parts;
            logRS = Math.Log10(Sum);
            double H = 0;
            for (int i = 0; i < newLength; i++) // Показатель Херста H
                H = logRS / (Math.Log10(newLength * Math.PI / 2.0));
            double logRSt = Math.Log10(Sum * 0.998752 + 1.051037);
            // Показатель Херста Ht
            double Ht = logRSt / (Math.Log10(newLength * Math.PI / 2.0)) * (-0.0011 * Math.Log(newLength) + 1.0136);
            return Math.Round(Ht, 4);
        }
    }
}